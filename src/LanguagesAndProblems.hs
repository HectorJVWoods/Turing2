module LanguagesAndProblems where

import Grammars
import EitherOrBoth
import Machine
import Set
-- Sorry this module is so long, I had to combine them to avoid a circular dependency

-- Languages are rather mysterious things; for some languages we know their exact structure, but for others we only know
-- Methods to check whether something is a member of a language.
-- This is the famous P vs NP problem; for problems in P we both know how to generate solutions in polynomial time
-- and verify those solutions, for NP problems we can only verify solutions in polynomial time.
-- it is unknown as to whether P = NP or not, but most experts believe it is not.
-- Therefore I give two methods of defining a language; either generate it with a generator, or check if it is a member
-- using a machine, or both. For P problems it should generally be easy to do both, and for NP problems, only possible to
-- use an Accepting Machine.
-- There are also problems for which neither is possible, known as undecidable problems.
-- Any language that can be given a yes/no answer by a Turing Machine in finite time is decidable, and therefore P or NP.
-- These languages are generated by Context-Sensitive Grammars. See Grammars.hs for more information.
-- There is also the notion of semidecidability; such languages can be given "yes" answers in finite time,
-- however for the "no" answers, the machine will halt on some inputs, but not others.
-- for semidecidability it is possible to say what is a member of the language, but it is not possible to say
-- with certainty that something is NOT part of the language.
-- Therefore, in short here are the possible languages, as I see it:
-- 1. Undecidable languages; not possible to generate or check membership.
-- 2. Semidecidable languages; possible to determine that something is a member, but not possible to rule out that some things are not.
--    i.e there is an acceptor that is semidecidable, but no generator.
-- 3. NP-Decidable languages; possible to check membership. i.e, there is an acceptor that is decidable, but no generator.
-- 4. P-Decidable languages; possible to generate and check membership. i.e, there is both a generator and an acceptor that are decidable.
-- Note that being generation implies acceptability; if we have a grammar that can generate a language, then we can
-- construct a turing machine that uses that grammar to check whether inputs are members of that language by derivation
-- using that grammar. However the same is not true in reverse; you cannot use an acceptor to create a generator for a language.
-- (at least provided P != NP. if P==NP, then it is possible there might be some very esoteric way to do it!)
-- For example, the language of prime numbers is NP-Decidable. Checking that a number is prime is relatively easy;
-- one method is to divide it by every integer from 1-n, and if it is divisible by any of them, then it is not prime.
-- however there is no known generator for prime numbers, and it is believed that there is no such generator.
--
-- Generators are simply Grammars, and define all of the rules that make up a language.
-- The great thing about them is that a simple set of rules can define a language containing an infinite number of members.
-- See Grammars.hs for more information on Grammars.
type Generator = Grammar
-- An acceptor is a machine that takes a set of symbols, and returns true if the set is a member of the language.
type Acceptor = Machine
type Language = EitherBothOrNeither Generator Acceptor
-- I consider "abstract languages" to be languages with neither a generator nor an acceptor. I call them abstract
-- since if we can neither generate nor check membership, then we are dealing with something we know/suspect might exist,
-- but cannot deal with any of its members. It's highly likely that most abstract languages are probably undecidable.
-- abstract languages might also be useful for users to define something to be implemented later, or to define a language
-- that is not yet known to be decidable or not.

isAbstractProblem :: Problem
isAbstractProblem = error "Todo, we need a language over languages to define this"

languageIsAbstract :: Language -> Bool
languageIsAbstract (A _) = False -- Has a generator, so not abstract
languageIsAbstract (B _) = True -- Has an acceptor, so not abstract
languageIsAbstract (Both _ _) = False -- Has both a generator and an acceptor, so not abstract
languageIsAbstract (Neither) = True -- Has neither a generator nor an acceptor, so abstract



type ProblemResult = [Symbol]
-- A "problem" can be considered as a "question" that takes an input, and produces one of n outputs.
-- It is possible for a problem to have an infinite number of outputs, as is the case with the problem of generating
-- all members of a non-regular language. The definition used here however, will be for problems framed by the user,
-- intended to be solved by a machine.
-- A problem can be considered as an input and the set of possible outputs for that problem. The input is a language, and
-- is fixed for that problem.
-- A machine that solves a problem will take a set of symbols as input, and produce one of the possible
-- problem results as output. We also give the problem a name to differentiate it from other problems that might
-- happen to have the same set of possible outputs.
type ProblemType = Set ProblemResult
type ProblemName = String
type Problem = (ProblemName, Language, ProblemType)
-- Some of you might be screaming at me "what do you mean a problem can't have multiple inputs?!", but it's important to remember
-- that the idea of two or more inputs offers no additional expressive power when dealing with strings of indeterminate length.
-- For example, let's say we have the problem of adding two numbers together. We can represent this as a problem with two inputs,
-- "5", and "7", and design a machine to solve this problem. However, we can also represent this as a problem with one input,
-- "57", and design a machine to solve this problem. The two machines are equivalent. This is the idea that a multitape Turing
-- Machine offers no expressive power over a single tape Turing Machine.
-- At the level of writing programs it is useful to consider multiple inputs, but at this level
-- it just makes defining what a problem is more complicated.


-- A decision problem is a problem that can be solved by a machine that returns a yes/no answer.
-- This is used a lot to define properties over grammars and turing machines. See Machine.hs for examples.
decisionProblem :: ProblemType
decisionProblem = setFromList [["Yes"], ["No"]]

newDecisionProblem :: ProblemName -> Language -> Problem
newDecisionProblem name language = (name, language, decisionProblem)