module Machine where

import Grammars
import EitherOrBoth

-- Languages are rather mysterious things; for some languages we know their exact structure, but for others we only know
-- Methods to check whether something is a member of a language.
-- This is the famous P vs NP problem; for problems in P we both know how to generate solutions in polynomial time
-- and verify those solutions, for NP problems we can only verify solutions in polynomial time.
-- it is unknown as to whether P = NP or not, but most experts believe it is not.
-- Therefore I give two methods of defining a language; either generate it with a generator, or check if it is a member
-- using a machine, or both. For P problems it should generally be easy to do both, and for NP problems, only possible to
-- use an Accepting Machine.
-- There are also problems for which neither is possible, known as undecidable problems.
-- Any language that can be given a yes/no answer by a Turing Machine in finite time is decidable, and therefore P or NP.
-- These languages are generated by Context-Sensitive Grammars. See Grammars.hs for more information.
-- There is also the notion of semidecidability; such languages can be given "yes" answers in finite time,
-- however for the "no" answers, the machine will halt on some inputs, but not others.
-- for semidecidability it is possible to say what is a member of the language, but it is not possible to say
-- with certainty that something is NOT part of the language.
-- Therefore, in short here are the possible languages, as I see it:
-- 1. Undecidable languages; not possible to generate or check membership.
-- 2. Semidecidable languages; possible to determine that something is a member, but not possible to rule out that some things are not.
--    i.e there is an acceptor that is semidecidable, but no generator.
-- 3. NP-Decidable languages; possible to check membership. i.e, there is an acceptor that is decidable, but no generator.
-- 4. P-Decidable languages; possible to generate and check membership. i.e, there is both a generator and an acceptor that are decidable.
-- Note that being generation implies acceptability; if we have a grammar that can generate a language, then we can
-- construct a turing machine that uses that grammar to check whether inputs are members of that language by derivation
-- using that grammar. However the same is not true in reverse; you cannot use an acceptor to create a generator for a language.
-- (at least provided P != NP. if P==NP, then it is possible there might be some very esoteric way to do it!)
-- For example, the language of prime numbers is NP-Decidable. Checking that a number is prime is relatively easy;
-- one method is to divide it by every integer from 1-n, and if it is divisible by any of them, then it is not prime.
-- however there is no known generator for prime numbers, and it is believed that there is no such generator.


-- Generators are simply Grammars, and define all of the rules that make up a language.
-- The great thing about them is that a simple set of rules can define a language containing an infinite number of members.
-- See Grammars.hs for more information on Grammars.
type Generator = Grammar
-- An acceptor is a machine that takes a set of symbols, and returns true if the set is a member of the language.
type Acceptor = Machine
type Language = EitherBothOrNeither Generator Acceptor


-- The most basic definition of a machine is something which takes a bunch of symbols, and converts them into a bunch of other symbols.
type Machine = ([Symbol] -> [Symbol])
